<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Exergy ‚àû Physics - Universal Navigator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0a0e27;
            background-image: 
                radial-gradient(2px 2px at 20% 30%, #fff, transparent),
                radial-gradient(2px 2px at 60% 70%, #fff, transparent),
                radial-gradient(1px 1px at 50% 50%, #fff, transparent),
                radial-gradient(1px 1px at 80% 10%, #fff, transparent),
                radial-gradient(2px 2px at 90% 60%, #fff, transparent),
                radial-gradient(1px 1px at 33% 80%, #fff, transparent),
                radial-gradient(2px 2px at 10% 40%, #fff, transparent),
                radial-gradient(1px 1px at 70% 20%, #fff, transparent);
            background-size: 200% 200%, 150% 150%, 180% 180%, 120% 120%, 160% 160%, 140% 140%, 130% 130%, 110% 110%;
            background-position: 0% 0%, 20% 20%, 40% 40%, 60% 60%, 80% 80%, 100% 100%, 0% 100%, 100% 0%;
            animation: float 20s ease-in-out infinite;
            height: 100vh;
            padding: 20px;
            position: relative;
            overflow: hidden;
            margin: 0;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(120, 119, 198, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 119, 198, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 20%, rgba(119, 198, 255, 0.1) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(15, 20, 40, 0.95);
            border-radius: 16px;
            box-shadow: 
                0 20px 60px rgba(0, 0, 0, 0.5),
                0 0 40px rgba(120, 119, 198, 0.2),
                inset 0 0 60px rgba(120, 119, 198, 0.05);
            overflow: hidden;
            border: 1px solid rgba(120, 119, 198, 0.3);
            position: relative;
            z-index: 1;
            height: calc(100vh - 40px);
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #1a1f3a 0%, #2d1b3d 50%, #1a1f3a 100%);
            color: #fff;
            padding: 40px 30px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, transparent 70%);
            animation: float 15s ease-in-out infinite;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5), 0 0 40px rgba(120, 119, 198, 0.5);
            position: relative;
            z-index: 1;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
            color: #b8b8ff;
            position: relative;
            z-index: 1;
        }

        .tabs-container {
            padding: 0 30px;
            background: rgba(20, 25, 45, 0.8);
            border-bottom: 1px solid rgba(120, 119, 198, 0.2);
            display: flex;
            gap: 10px;
        }

        .tab {
            padding: 12px 24px;
            background: rgba(15, 20, 40, 0.5);
            border: 2px solid rgba(120, 119, 198, 0.3);
            border-radius: 8px 8px 0 0;
            color: rgba(184, 184, 255, 0.7);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
            font-weight: 500;
            position: relative;
            top: 2px;
            border-bottom: none;
        }

        .tab:hover {
            background: rgba(20, 25, 45, 0.7);
            color: rgba(184, 184, 255, 0.9);
            border-color: rgba(120, 119, 198, 0.5);
        }

        .tab.active {
            background: rgba(20, 25, 45, 0.9);
            color: #b8b8ff;
            border-color: rgba(120, 119, 198, 0.6);
            border-bottom: 2px solid rgba(20, 25, 45, 0.9);
            top: 0;
            box-shadow: 0 -2px 10px rgba(120, 119, 198, 0.2);
        }

        /* Mobile responsive styles for iPhone and small screens */
        @media screen and (max-width: 768px) {
            .tabs-container {
                padding: 0 10px;
                gap: 6px;
                flex-wrap: nowrap;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: none; /* Firefox */
            }

            .tabs-container::-webkit-scrollbar {
                display: none; /* Chrome, Safari, Edge */
            }

            .tab {
                padding: 10px 14px;
                font-size: 0.85em;
                white-space: nowrap;
                flex-shrink: 0;
                min-width: auto;
            }

            body {
                padding: 10px;
            }

            .container {
                height: calc(100vh - 20px);
            }

            .header {
                padding: 20px 15px;
            }

            .search-container {
                padding: 15px;
            }
        }

        /* iPhone specific portrait orientation */
        @media screen and (max-width: 480px) and (orientation: portrait) {
            .tabs-container {
                padding: 0 8px;
                gap: 4px;
            }

            .tab {
                padding: 8px 10px;
                font-size: 0.8em;
                border-radius: 6px 6px 0 0;
            }

            .header {
                padding: 15px 10px;
                font-size: 0.9em;
            }
        }

        .search-container {
            padding: 30px;
            background: rgba(20, 25, 45, 0.8);
            border-bottom: 1px solid rgba(120, 119, 198, 0.2);
        }

        .search-box {
            width: 100%;
            padding: 15px 20px;
            font-size: 1.1em;
            border: 2px solid rgba(120, 119, 198, 0.4);
            border-radius: 8px;
            outline: none;
            transition: all 0.3s ease;
            background: rgba(10, 14, 27, 0.6);
            color: #fff;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .search-box::placeholder {
            color: rgba(184, 184, 255, 0.5);
        }

        .search-box:focus {
            border-color: rgba(184, 184, 255, 0.8);
            box-shadow: 
                0 0 0 3px rgba(120, 119, 198, 0.2),
                0 0 20px rgba(120, 119, 198, 0.3),
                inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .split-container {
            display: flex;
            flex: 1;
            overflow: hidden;
            gap: 20px;
            padding: 30px;
            background: rgba(15, 20, 40, 0.5);
        }

        .tree-container {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .tree-container.left {
            border-right: 2px solid rgba(120, 119, 198, 0.3);
            padding-right: 20px;
        }

        .tree-container.right {
            padding-left: 20px;
        }

        .tree-container-header {
            font-size: 1.2em;
            font-weight: 600;
            color: #b8b8ff;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(120, 119, 198, 0.3);
        }

        .tree-container::-webkit-scrollbar {
            width: 8px;
        }

        .tree-container::-webkit-scrollbar-track {
            background: rgba(10, 14, 27, 0.5);
        }

        .tree-container::-webkit-scrollbar-thumb {
            background: rgba(120, 119, 198, 0.4);
            border-radius: 4px;
        }

        .tree-container::-webkit-scrollbar-thumb:hover {
            background: rgba(120, 119, 198, 0.6);
        }

        .tree {
            list-style: none;
            overflow: visible;
            height: 100%;
        }

        .tree-node {
            margin: 8px 0;
        }

        .tree-node-content {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
            background: rgba(15, 20, 40, 0.3);
            position: relative;
            overflow: visible;
        }

        .tree-node-content:hover {
            background: rgba(120, 119, 198, 0.15);
            box-shadow: 0 0 15px rgba(120, 119, 198, 0.3);
            transform: translateX(3px);
        }

        .tree-node-content.highlight {
            background: rgba(255, 193, 7, 0.15);
            box-shadow: 0 0 15px rgba(255, 193, 7, 0.4);
        }

        .tree-node-content.matched {
            background: rgba(40, 167, 69, 0.15);
            box-shadow: 0 0 15px rgba(40, 167, 69, 0.4);
        }

        .tree-toggle {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background: rgba(120, 119, 198, 0.6);
            color: white;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 0 10px rgba(120, 119, 198, 0.4);
        }

        .tree-toggle:hover {
            background: rgba(184, 184, 255, 0.8);
            box-shadow: 0 0 15px rgba(120, 119, 198, 0.6);
            transform: scale(1.1);
        }

        .tree-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .tree-toggle.no-children {
            background: transparent;
            cursor: default;
            color: rgba(184, 184, 255, 0.6);
            box-shadow: none;
            font-size: 16px;
        }

        .tree-label {
            font-size: 1em;
            color: #e0e0ff;
            font-weight: 500;
            transition: color 0.2s ease;
        }

        .tree-label:hover {
            opacity: 0.8;
        }

        .tree-tooltip {
            position: relative;
            display: inline-block;
        }

        .tree-tooltip::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 20, 40, 0.98);
            color: rgba(184, 184, 255, 0.95);
            padding: 10px 14px;
            border-radius: 8px;
            font-size: 0.85em;
            font-style: italic;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            z-index: 10000;
            border: 1px solid rgba(120, 119, 198, 0.4);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.6);
            max-width: 400px;
            min-width: 200px;
            white-space: pre-line;
            text-align: left;
            visibility: hidden;
            word-wrap: break-word;
            line-height: 1.5;
        }

        .tree-tooltip:hover::after {
            opacity: 1;
            visibility: visible;
        }

        .tree-children {
            margin-left: 30px;
            margin-top: 5px;
            display: block;
        }

        .tree-children.hidden {
            display: none;
        }

        .stats {
            padding: 15px 30px;
            background: rgba(20, 25, 45, 0.8);
            border-top: 1px solid rgba(120, 119, 198, 0.2);
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
            color: #b8b8ff;
        }

        .copyright {
            padding: 15px 30px;
            background: rgba(10, 14, 27, 0.8);
            border-top: 1px solid rgba(120, 119, 198, 0.1);
            text-align: center;
            font-size: 0.85em;
            color: rgba(184, 184, 255, 0.6);
        }

        .no-results {
            text-align: center;
            padding: 40px;
            color: rgba(184, 184, 255, 0.5);
            font-size: 1.1em;
        }

        .context-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 100000;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(4px);
        }

        .context-modal.active {
            display: flex;
        }

        .context-modal-content {
            background: rgba(15, 20, 40, 0.98);
            border-radius: 12px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            border: 1px solid rgba(120, 119, 198, 0.4);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
            position: relative;
        }

        .context-modal-header {
            margin-bottom: 20px;
        }

        .context-modal-title {
            font-size: 1.5em;
            color: #e0e0ff;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .context-modal-year {
            font-size: 1em;
            color: rgba(184, 184, 255, 0.7);
            margin-bottom: 15px;
        }

        .context-modal-summary {
            font-size: 1em;
            color: rgba(184, 184, 255, 0.9);
            line-height: 1.6;
            margin-bottom: 20px;
            font-style: italic;
        }

        .context-modal-people {
            margin-bottom: 25px;
        }

        .context-modal-people-label {
            font-size: 0.9em;
            color: rgba(184, 184, 255, 0.7);
            margin-bottom: 8px;
            font-weight: 500;
        }

        .context-modal-people-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .context-modal-person {
            display: inline-block;
            padding: 6px 12px;
            background: rgba(120, 119, 198, 0.2);
            border: 1px solid rgba(120, 119, 198, 0.4);
            border-radius: 6px;
            color: rgba(184, 184, 255, 0.9);
            text-decoration: none;
            font-size: 0.9em;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .context-modal-person:hover {
            background: rgba(120, 119, 198, 0.4);
            border-color: rgba(120, 119, 198, 0.6);
            color: #fff;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(120, 119, 198, 0.3);
        }

        .context-modal-tags {
            margin-bottom: 25px;
        }

        .context-modal-tags-label {
            font-size: 0.9em;
            color: rgba(184, 184, 255, 0.7);
            margin-bottom: 8px;
            font-weight: 500;
        }

        .context-modal-tags-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .context-modal-tag {
            display: inline-block;
            padding: 6px 12px;
            background: rgba(120, 119, 198, 0.2);
            border: 1px solid rgba(120, 119, 198, 0.4);
            border-radius: 6px;
            color: rgba(184, 184, 255, 0.9);
            text-decoration: none;
            font-size: 0.9em;
            transition: all 0.2s ease;
            cursor: pointer;
            position: relative;
        }

        .context-modal-tag:hover {
            background: rgba(120, 119, 198, 0.4);
            border-color: rgba(120, 119, 198, 0.6);
            color: #fff;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(120, 119, 198, 0.3);
        }

        .context-modal-tag-tooltip {
            visibility: hidden;
            opacity: 0;
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-8px);
            background: rgba(15, 20, 40, 0.98);
            color: rgba(184, 184, 255, 0.9);
            padding: 10px 14px;
            border-radius: 6px;
            border: 1px solid rgba(120, 119, 198, 0.4);
            font-size: 0.85em;
            line-height: 1.4;
            width: 400px;
            max-width: 400px;
            white-space: normal;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            transition: opacity 0.2s ease, visibility 0.2s ease, transform 0.2s ease;
            pointer-events: none;
        }

        .context-modal-tag:hover .context-modal-tag-tooltip {
            visibility: visible;
            opacity: 1;
            transform: translateX(-50%) translateY(-12px);
        }

        .context-modal-tag-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: rgba(120, 119, 198, 0.4);
        }

        .context-modal-papers {
            margin-bottom: 25px;
        }

        .context-modal-papers-label {
            font-size: 0.9em;
            color: rgba(184, 184, 255, 0.7);
            margin-bottom: 8px;
            font-weight: 500;
        }

        .context-modal-papers-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .context-modal-paper {
            display: inline-block;
            padding: 8px 14px;
            background: rgba(120, 119, 198, 0.15);
            border: 1px solid rgba(120, 119, 198, 0.3);
            border-radius: 6px;
            color: rgba(184, 184, 255, 0.9);
            text-decoration: none;
            transition: all 0.3s ease;
            font-size: 0.9em;
        }

        .context-modal-paper:hover {
            background: rgba(120, 119, 198, 0.3);
            border-color: rgba(120, 119, 198, 0.5);
            color: #fff;
            transform: translateX(3px);
        }

        .context-modal-nobel {
            margin-bottom: 25px;
        }

        .context-modal-nobel-label {
            font-size: 0.9em;
            color: rgba(255, 215, 0, 0.9);
            margin-bottom: 8px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .context-modal-nobel-label::before {
            content: 'üèÜ';
            font-size: 1.2em;
        }

        .context-modal-nobel-topic {
            background: rgba(255, 215, 0, 0.15);
            border: 1px solid rgba(255, 215, 0, 0.4);
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 12px;
        }

        .context-modal-nobel-topic-year {
            font-size: 0.95em;
            color: rgba(255, 215, 0, 0.9);
            font-weight: 600;
            margin-bottom: 6px;
        }

        .context-modal-nobel-topic-description {
            font-size: 0.9em;
            color: rgba(255, 215, 0, 0.8);
            line-height: 1.5;
        }

        .context-modal-nobel-people {
            margin-top: 12px;
        }

        .context-modal-nobel-people-label {
            font-size: 0.85em;
            color: rgba(255, 215, 0, 0.7);
            margin-bottom: 6px;
            font-weight: 500;
        }

        .context-modal-nobel-people-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .context-modal-nobel-person {
            display: inline-block;
            padding: 4px 10px;
            background: rgba(255, 215, 0, 0.15);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 4px;
            color: rgba(255, 215, 0, 0.9);
            font-size: 0.85em;
        }

        .context-modal-nobel-person-year {
            color: rgba(255, 215, 0, 0.7);
            font-size: 0.9em;
            margin-left: 4px;
        }

        .context-modal-nobel-person {
            position: relative;
        }

        .context-modal-nobel-person-tooltip {
            visibility: hidden;
            opacity: 0;
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-8px);
            background: rgba(15, 20, 40, 0.98);
            color: rgba(255, 215, 0, 0.9);
            padding: 10px 14px;
            border-radius: 6px;
            border: 1px solid rgba(255, 215, 0, 0.4);
            font-size: 0.85em;
            line-height: 1.4;
            width: 400px;
            max-width: 400px;
            white-space: normal;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            transition: opacity 0.2s ease, visibility 0.2s ease, transform 0.2s ease;
            pointer-events: none;
            margin-bottom: 8px;
        }

        .context-modal-nobel-person:hover .context-modal-nobel-person-tooltip {
            visibility: visible;
            opacity: 1;
            transform: translateX(-50%) translateY(-12px);
        }

        .context-modal-nobel-person-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: rgba(255, 215, 0, 0.4);
        }

        .context-modal-nobel-person-tooltip-year {
            font-weight: 600;
            color: rgba(255, 215, 0, 1);
            margin-bottom: 4px;
        }

        .context-modal-nobel-person-tooltip-description {
            margin-bottom: 8px;
        }

        .context-modal-nobel-person-tooltip-description:last-child {
            margin-bottom: 0;
        }

        .context-modal-actions {
            display: flex;
            gap: 15px;
            justify-content: flex-end;
        }

        .context-modal-button {
            padding: 10px 20px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-size: 1em;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .context-modal-button.primary {
            background: rgba(120, 119, 198, 0.8);
            color: #fff;
        }

        .context-modal-button.primary:hover {
            background: rgba(120, 119, 198, 1);
            box-shadow: 0 0 15px rgba(120, 119, 198, 0.5);
        }

        .context-modal-button.secondary {
            background: rgba(60, 60, 80, 0.6);
            color: rgba(184, 184, 255, 0.9);
        }

        .context-modal-button.secondary:hover {
            background: rgba(60, 60, 80, 0.8);
        }

        .context-modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: transparent;
            border: none;
            color: rgba(184, 184, 255, 0.7);
            font-size: 1.5em;
            cursor: pointer;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .context-modal-close:hover {
            background: rgba(120, 119, 198, 0.2);
            color: rgba(184, 184, 255, 1);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üåå Exergy ‚àû Physics</h1>
            <p>Exploring and expanding on humanity's collective understanding</p>
        </div>
        
        <div class="tabs-container">
            <div class="tab active" data-view="concepts">Concepts</div>
            <div class="tab" data-view="people">People</div>
            <div class="tab" data-view="tags">Tags</div>
            <div class="tab" data-view="papers">Papers</div>
        </div>
        
        <div class="search-container">
            <input 
                type="text" 
                class="search-box" 
                id="searchBox" 
                placeholder="Enter search criteria..."
                autocomplete="off"
            />
        </div>

        <div class="split-container">
            <div class="tree-container left">
                <div class="tree-container-header">Theories</div>
                <ul class="tree" id="treeRoot"></ul>
                <div class="no-results" id="noResults" style="display: none;">
                    No results found
                </div>
            </div>
            <div class="tree-container right">
                <div class="tree-container-header">Anomalies</div>
                <ul class="tree" id="anomalyTreeRoot"></ul>
                <div class="no-results" id="anomalyNoResults" style="display: none;">
                    No anomalies found
                </div>
            </div>
        </div>

        <div class="stats">
            <span id="conceptCount">Total concepts: 0</span>
            <span id="peopleCount">Total people: 0</span>
            <span id="tagCount">Total tags: 0</span>
            <span id="paperCount">Total papers: 0</span>
            <span id="matchCount">Matches: 0</span>
        </div>

        <div class="copyright">
            ¬© 2026 Exergy ‚àû LLC | Version 2026-02-12.1 | <a href="index_v1.html" style="color: rgba(120, 119, 198, 0.8); text-decoration: none;">v1</a>
        </div>
    </div>

    <!-- Context Modal -->
    <div class="context-modal" id="contextModal">
        <div class="context-modal-content">
            <button class="context-modal-close" id="contextModalClose">&times;</button>
            <div class="context-modal-header">
                <div class="context-modal-title" id="contextModalTitle"></div>
                <div class="context-modal-year" id="contextModalYear"></div>
            </div>
            <div class="context-modal-summary" id="contextModalSummary"></div>
            <div class="context-modal-tags" id="contextModalTags"></div>
            <div class="context-modal-people" id="contextModalPeople"></div>
            <div class="context-modal-papers" id="contextModalPapers"></div>
            <div class="context-modal-nobel" id="contextModalNobel"></div>
            <div class="context-modal-actions">
                <button class="context-modal-button secondary" id="contextModalCancel">Cancel</button>
                <button class="context-modal-button primary" id="contextModalWikipedia">Open Wikipedia</button>
            </div>
        </div>
    </div>

    <script src="data/output/consolidated_data.js"></script>
    <script>
        // Global variable to hold the loaded hierarchy data
        let sampleHierarchy = null;
        let currentView = 'concepts'; // 'concepts', 'people', 'tags', 'papers'
        let consolidatedDataGlobal = null; // Store consolidated data for view switching
        
        // Load consolidated data asynchronously
        async function loadConsolidatedData() {
            try {
                if (typeof getConsolidatedData === 'undefined') {
                    throw new Error('getConsolidatedData function not found. Make sure data/output/consolidated_data.js is loaded.');
                }
                const data = await getConsolidatedData();
                return data;
            } catch (error) {
                console.error('Error loading consolidated data:', error);
                // Fallback to sync version if available
                if (typeof getConsolidatedDataSync !== 'undefined') {
                    try {
                        return getConsolidatedDataSync();
                    } catch (syncError) {
                        console.error('Error loading consolidated data (sync fallback):', syncError);
                        throw syncError;
                    }
                }
                throw error;
            }
        }

        // Convert consolidated data format to hierarchical format expected by UI
        function convertConsolidatedDataToHierarchy(consolidatedData) {
            if (!consolidatedData || !consolidatedData.data || !consolidatedData.data.theory) {
                console.error('Invalid consolidated data format');
                return null;
            }

            const theories = consolidatedData.data.theory;
            
            // Build a map of theory_id -> theory object
            const theoryMap = new Map();
            Object.values(theories).forEach(theory => {
                theoryMap.set(theory.theory_id, theory);
            });

            // Group theories by category
            const theoriesByCategory = {};
            Object.values(theories).forEach(theory => {
                if (!theory.parent_theory_id) { // Top-level theories (no parent)
                    const category = theory.category || 'Other';
                    if (!theoriesByCategory[category]) {
                        theoriesByCategory[category] = [];
                    }
                    theoriesByCategory[category].push(theory);
                }
            });

            // Build hierarchical structure
            function buildHierarchy(theory) {
                const node = {
                    name: theory.name,
                    year: theory.year,
                    summary: theory.summary,
                    people: theory.people || [],
                    tags: theory.tags || [],
                    papers: theory.papers || [],
                    nobel: theory.nobel_year,
                    theory_id: theory.theory_id,  // Store theory_id for prize lookup
                    children: []
                };

                // Find children (theories with this theory as parent)
                Object.values(theories).forEach(childTheory => {
                    if (childTheory.parent_theory_id === theory.theory_id) {
                        node.children.push(buildHierarchy(childTheory));
                    }
                });

                // Add nested assumptions, postulates, and claims as children
                if (theory.assumptions && theory.assumptions.length > 0) {
                    theory.assumptions.forEach(assumption => {
                        node.children.push({
                            name: `Assumption: ${assumption.statement.substring(0, 50)}...`,
                            year: theory.year,
                            summary: assumption.statement,
                            rationale: assumption.rationale,
                            parentTheory: node  // Store reference to parent theory
                        });
                    });
                }

                if (theory.postulates && theory.postulates.length > 0) {
                    theory.postulates.forEach(postulate => {
                        node.children.push({
                            name: `Postulate: ${postulate.statement.substring(0, 50)}...`,
                            year: postulate.formulation_year || theory.year,
                            summary: postulate.statement,
                            parentTheory: node  // Store reference to parent theory
                        });
                    });
                }

                if (theory.claims && theory.claims.length > 0) {
                    theory.claims.forEach(claim => {
                        node.children.push({
                            name: `Claim: ${claim.statement.substring(0, 50)}...`,
                            year: claim.verification_year || theory.year,
                            summary: claim.statement,
                            status: claim.status,
                            parentTheory: node  // Store reference to parent theory
                        });
                    });
                }

                // Add nested predictions as children
                if (theory.predictions && theory.predictions.length > 0) {
                    theory.predictions.forEach(prediction => {
                        node.children.push({
                            name: `Prediction: ${prediction.statement.substring(0, 50)}...`,
                            year: prediction.prediction_year || theory.year,
                            summary: prediction.statement,
                            prediction_year: prediction.prediction_year,
                            verification_year: prediction.verification_year,
                            verification_method: prediction.verification_method,
                            status: prediction.status,
                            parentTheory: node  // Store reference to parent theory
                        });
                    });
                }

                // Sort children by year
                node.children.sort((a, b) => (a.year || 0) - (b.year || 0));

                return node;
            }

            // Build root structure with categories
            const rootChildren = [];
            const categoryOrder = ['Classical Mechanics', 'Quantum Physics', 'Relativity', 'Thermodynamics', 'Electromagnetism', 'Particle Physics'];
            
            categoryOrder.forEach(category => {
                if (theoriesByCategory[category] && theoriesByCategory[category].length > 0) {
                    const categoryNode = {
                        name: category,
                        year: Math.min(...theoriesByCategory[category].map(t => t.year || 0)),
                        children: theoriesByCategory[category]
                            .sort((a, b) => (a.year || 0) - (b.year || 0))
                            .map(theory => buildHierarchy(theory))
                    };
                    rootChildren.push(categoryNode);
                }
            });

            // Add any uncategorized theories
            Object.keys(theoriesByCategory).forEach(category => {
                if (!categoryOrder.includes(category)) {
                    const categoryNode = {
                        name: category,
                        year: Math.min(...theoriesByCategory[category].map(t => t.year || 0)),
                        children: theoriesByCategory[category]
                            .sort((a, b) => (a.year || 0) - (b.year || 0))
                            .map(theory => buildHierarchy(theory))
                    };
                    rootChildren.push(categoryNode);
                }
            });

            return {
                name: "Physics as known today",
                year: 2026,
                children: rootChildren
            };
        }

        // Convert to People-centric view
        function convertToPeopleView(consolidatedData) {
            if (!consolidatedData || !consolidatedData.data) {
                return null;
            }

            const people = consolidatedData.data.person || {};
            const theories = consolidatedData.data.theory || {};
            const peopleMap = new Map();

            // Build map of person_id -> theories
            Object.values(theories).forEach(theory => {
                if (theory.people && Array.isArray(theory.people)) {
                    theory.people.forEach(personId => {
                        if (!peopleMap.has(personId)) {
                            peopleMap.set(personId, []);
                        }
                        peopleMap.get(personId).push(theory);
                    });
                }
            });

            // Build hierarchy grouped by people
            const peopleNodes = [];
            Object.values(people).forEach(person => {
                const personTheories = peopleMap.get(person.person_id) || [];
                if (personTheories.length > 0) {
                    const personNode = {
                        name: person.name,
                        year: person.birth_year || 0,
                        summary: `${person.name} (${person.birth_year || '?'} - ${person.death_year || '?'})`,
                        person_id: person.person_id,
                        children: personTheories
                            .sort((a, b) => (a.year || 0) - (b.year || 0))
                            .map(theory => {
                                const node = {
                                    name: theory.name,
                                    year: theory.year,
                                    summary: theory.summary,
                                    theory_id: theory.theory_id,
                                    people: theory.people || [],
                                    tags: theory.tags || [],
                                    papers: theory.papers || [],
                                    children: []
                                };
                                // Add nested items
                                if (theory.assumptions) {
                                    theory.assumptions.forEach(a => {
                                        node.children.push({
                                            name: `Assumption: ${a.statement.substring(0, 50)}...`,
                                            year: theory.year,
                                            summary: a.statement,
                                            parentTheory: node
                                        });
                                    });
                                }
                                if (theory.postulates) {
                                    theory.postulates.forEach(p => {
                                        node.children.push({
                                            name: `Postulate: ${p.statement.substring(0, 50)}...`,
                                            year: p.formulation_year || theory.year,
                                            summary: p.statement,
                                            parentTheory: node
                                        });
                                    });
                                }
                                if (theory.claims) {
                                    theory.claims.forEach(c => {
                                        node.children.push({
                                            name: `Claim: ${c.statement.substring(0, 50)}...`,
                                            year: c.verification_year || theory.year,
                                            summary: c.statement,
                                            parentTheory: node
                                        });
                                    });
                                }
                                if (theory.predictions) {
                                    theory.predictions.forEach(p => {
                                        node.children.push({
                                            name: `Prediction: ${p.statement.substring(0, 50)}...`,
                                            year: p.prediction_year || theory.year,
                                            summary: p.statement,
                                            prediction_year: p.prediction_year,
                                            verification_year: p.verification_year,
                                            verification_method: p.verification_method,
                                            status: p.status,
                                            parentTheory: node
                                        });
                                    });
                                }
                                return node;
                            })
                    };
                    peopleNodes.push(personNode);
                }
            });

            // Sort by birth year
            peopleNodes.sort((a, b) => (a.year || 0) - (b.year || 0));

            return {
                name: "Physics by People",
                year: 2026,
                children: peopleNodes
            };
        }

        // Convert to Tags-centric view
        function convertToTagsView(consolidatedData) {
            if (!consolidatedData || !consolidatedData.data) {
                return null;
            }

            const tags = consolidatedData.data.tag || {};
            const theories = consolidatedData.data.theory || {};
            const tagsMap = new Map();

            // Build map of tag_id -> theories
            Object.values(theories).forEach(theory => {
                if (theory.tags && Array.isArray(theory.tags)) {
                    theory.tags.forEach(tagId => {
                        if (!tagsMap.has(tagId)) {
                            tagsMap.set(tagId, []);
                        }
                        tagsMap.get(tagId).push(theory);
                    });
                }
            });

            // Build hierarchy grouped by tags
            const tagNodes = [];
            Object.values(tags).forEach(tag => {
                const tagTheories = tagsMap.get(tag.tag_id) || [];
                if (tagTheories.length > 0) {
                    const tagNode = {
                        name: tag.name,
                        year: Math.min(...tagTheories.map(t => t.year || 0)),
                        summary: `Theories tagged with: ${tag.name}`,
                        tag_id: tag.tag_id,
                        children: tagTheories
                            .sort((a, b) => (a.year || 0) - (b.year || 0))
                            .map(theory => {
                                const node = {
                                    name: theory.name,
                                    year: theory.year,
                                    summary: theory.summary,
                                    theory_id: theory.theory_id,
                                    people: theory.people || [],
                                    tags: theory.tags || [],
                                    papers: theory.papers || [],
                                    children: []
                                };
                                // Add nested items (same as people view)
                                if (theory.assumptions) {
                                    theory.assumptions.forEach(a => {
                                        node.children.push({
                                            name: `Assumption: ${a.statement.substring(0, 50)}...`,
                                            year: theory.year,
                                            summary: a.statement,
                                            parentTheory: node
                                        });
                                    });
                                }
                                if (theory.postulates) {
                                    theory.postulates.forEach(p => {
                                        node.children.push({
                                            name: `Postulate: ${p.statement.substring(0, 50)}...`,
                                            year: p.formulation_year || theory.year,
                                            summary: p.statement,
                                            parentTheory: node
                                        });
                                    });
                                }
                                if (theory.claims) {
                                    theory.claims.forEach(c => {
                                        node.children.push({
                                            name: `Claim: ${c.statement.substring(0, 50)}...`,
                                            year: c.verification_year || theory.year,
                                            summary: c.statement,
                                            parentTheory: node
                                        });
                                    });
                                }
                                if (theory.predictions) {
                                    theory.predictions.forEach(p => {
                                        node.children.push({
                                            name: `Prediction: ${p.statement.substring(0, 50)}...`,
                                            year: p.prediction_year || theory.year,
                                            summary: p.statement,
                                            prediction_year: p.prediction_year,
                                            verification_year: p.verification_year,
                                            verification_method: p.verification_method,
                                            status: p.status,
                                            parentTheory: node
                                        });
                                    });
                                }
                                return node;
                            })
                    };
                    tagNodes.push(tagNode);
                }
            });

            // Sort by name
            tagNodes.sort((a, b) => a.name.localeCompare(b.name));

            return {
                name: "Physics by Tags",
                year: 2026,
                children: tagNodes
            };
        }

        // Convert to Papers-centric view
        function convertToPapersView(consolidatedData) {
            if (!consolidatedData || !consolidatedData.data) {
                return null;
            }

            const papers = consolidatedData.data.paper || {};
            const theories = consolidatedData.data.theory || {};
            const papersMap = new Map();

            // Build map of paper_id -> theories
            Object.values(theories).forEach(theory => {
                if (theory.papers && Array.isArray(theory.papers)) {
                    theory.papers.forEach(paperId => {
                        if (!papersMap.has(paperId)) {
                            papersMap.set(paperId, []);
                        }
                        papersMap.get(paperId).push(theory);
                    });
                }
            });

            // Build hierarchy grouped by papers
            const paperNodes = [];
            Object.values(papers).forEach(paper => {
                const paperTheories = papersMap.get(paper.paper_id) || [];
                if (paperTheories.length > 0) {
                    const paperNode = {
                        name: paper.title,
                        year: paper.year || 0,
                        summary: `${paper.title} (${paper.year || '?'})`,
                        paper_id: paper.paper_id,
                        link: paper.link,
                        children: paperTheories
                            .sort((a, b) => (a.year || 0) - (b.year || 0))
                            .map(theory => {
                                const node = {
                                    name: theory.name,
                                    year: theory.year,
                                    summary: theory.summary,
                                    theory_id: theory.theory_id,
                                    people: theory.people || [],
                                    tags: theory.tags || [],
                                    papers: theory.papers || [],
                                    children: []
                                };
                                // Add nested items (same as people view)
                                if (theory.assumptions) {
                                    theory.assumptions.forEach(a => {
                                        node.children.push({
                                            name: `Assumption: ${a.statement.substring(0, 50)}...`,
                                            year: theory.year,
                                            summary: a.statement,
                                            parentTheory: node
                                        });
                                    });
                                }
                                if (theory.postulates) {
                                    theory.postulates.forEach(p => {
                                        node.children.push({
                                            name: `Postulate: ${p.statement.substring(0, 50)}...`,
                                            year: p.formulation_year || theory.year,
                                            summary: p.statement,
                                            parentTheory: node
                                        });
                                    });
                                }
                                if (theory.claims) {
                                    theory.claims.forEach(c => {
                                        node.children.push({
                                            name: `Claim: ${c.statement.substring(0, 50)}...`,
                                            year: c.verification_year || theory.year,
                                            summary: c.statement,
                                            parentTheory: node
                                        });
                                    });
                                }
                                if (theory.predictions) {
                                    theory.predictions.forEach(p => {
                                        node.children.push({
                                            name: `Prediction: ${p.statement.substring(0, 50)}...`,
                                            year: p.prediction_year || theory.year,
                                            summary: p.statement,
                                            prediction_year: p.prediction_year,
                                            verification_year: p.verification_year,
                                            verification_method: p.verification_method,
                                            status: p.status,
                                            parentTheory: node
                                        });
                                    });
                                }
                                return node;
                            })
                    };
                    paperNodes.push(paperNode);
                }
            });

            // Sort by year
            paperNodes.sort((a, b) => (a.year || 0) - (b.year || 0));

            return {
                name: "Physics by Papers",
                year: 2026,
                children: paperNodes
            };
        }

        // Get hierarchy based on current view
        function getHierarchyForView(view, consolidatedData) {
            switch(view) {
                case 'concepts':
                    return convertConsolidatedDataToHierarchy(consolidatedData);
                case 'people':
                    return convertToPeopleView(consolidatedData);
                case 'tags':
                    return convertToTagsView(consolidatedData);
                case 'papers':
                    return convertToPapersView(consolidatedData);
                default:
                    return convertConsolidatedDataToHierarchy(consolidatedData);
            }
        }

        // Trie Node class
        class TrieNode {
            constructor() {
                this.children = new Map();
                this.isEndOfWord = false;
                this.nodes = []; // Store references to tree nodes that end here
            }
        }

        // Trie data structure
        class Trie {
            constructor() {
                this.root = new TrieNode();
            }

            // Insert a word into the trie with a reference to the tree node
            insert(word, treeNode) {
                let current = this.root;
                const lowerWord = word.toLowerCase();
                
                for (let char of lowerWord) {
                    if (!current.children.has(char)) {
                        current.children.set(char, new TrieNode());
                    }
                    current = current.children.get(char);
                }
                
                current.isEndOfWord = true;
                current.nodes.push(treeNode);
            }

            // Search for all words that start with the given prefix
            search(prefix) {
                let current = this.root;
                const lowerPrefix = prefix.toLowerCase();
                
                // Navigate to the prefix node
                for (let char of lowerPrefix) {
                    if (!current.children.has(char)) {
                        return [];
                    }
                    current = current.children.get(char);
                }
                
                // Collect all words from this node
                const results = [];
                this._collectAll(current, lowerPrefix, results);
                return results;
            }

            // Search for all nodes where the search term appears anywhere in any stored word
            // This searches both node names and people names
            searchSubstring(searchTerm) {
                const lowerSearch = searchTerm.toLowerCase();
                const results = [];
                const seenNodes = new Set(); // Avoid duplicates
                
                // Traverse entire trie and check all stored words
                this._searchSubstringRecursive(this.root, '', lowerSearch, results, seenNodes);
                
                return results;
            }

            _searchSubstringRecursive(node, currentWord, searchTerm, results, seenNodes) {
                // Check if current word contains the search term
                // Check at every node, not just end of word, to allow matching substrings
                if (currentWord.includes(searchTerm)) {
                    // If this is an end of word node, add all associated nodes
                    if (node.isEndOfWord && node.nodes) {
                        node.nodes.forEach(treeNode => {
                            if (!seenNodes.has(treeNode.name)) {
                                seenNodes.add(treeNode.name);
                                results.push(treeNode);
                            }
                        });
                    }
                    // Also collect all end-of-word nodes in the subtree that contain the search term
                    // This ensures we match even if the search term appears in the middle of a longer word
                    this._collectMatchingNodes(node, currentWord, results, seenNodes, searchTerm);
                }
                
                // Continue searching children
                for (let [char, childNode] of node.children) {
                    this._searchSubstringRecursive(childNode, currentWord + char, searchTerm, results, seenNodes);
                }
            }
            
            // Helper to collect all matching nodes from a subtree
            _collectMatchingNodes(node, prefix, results, seenNodes, searchTerm) {
                if (node.isEndOfWord && node.nodes) {
                    // Only add if the full word contains the search term
                    if (prefix.includes(searchTerm)) {
                        node.nodes.forEach(treeNode => {
                            if (!seenNodes.has(treeNode.name)) {
                                seenNodes.add(treeNode.name);
                                results.push(treeNode);
                            }
                        });
                    }
                }
                
                for (let [char, childNode] of node.children) {
                    this._collectMatchingNodes(childNode, prefix + char, results, seenNodes, searchTerm);
                }
            }

            // Helper method to collect all words from a node
            _collectAll(node, prefix, results) {
                if (node.isEndOfWord) {
                    results.push(...node.nodes);
                }
                
                for (let [char, childNode] of node.children) {
                    this._collectAll(childNode, prefix + char, results);
                }
            }

            // Check if a prefix exists in the trie
            hasPrefix(prefix) {
                let current = this.root;
                const lowerPrefix = prefix.toLowerCase();
                
                for (let char of lowerPrefix) {
                    if (!current.children.has(char)) {
                        return false;
                    }
                    current = current.children.get(char);
                }
                
                return true;
            }
        }

        // Build trie from tree structure, including people names and tags
        function buildTrie(node, trie) {
            // Insert node name
            trie.insert(node.name, node);
            
            // For predictions, also insert the full statement for better searchability
            if (node.name.startsWith('Prediction:') && node.summary) {
                // Insert key terms from the prediction statement
                const words = node.summary.toLowerCase().split(/\s+/);
                words.forEach(word => {
                    if (word.length > 3) { // Only index words longer than 3 characters
                        trie.insert(word, node);
                    }
                });
            }
            
            // For anomalies and violated assumptions, index description and explanation text
            // BUT: only index full words, and require word boundaries for matching
            // This prevents "hub" from matching "hubble" unless it's a complete word
            if (node.anomaly_id || node.violated_assumption_id || node.summary || node.explanation) {
                if (node.summary) {
                    const words = node.summary.toLowerCase().split(/\s+/);
                    words.forEach(word => {
                        // Clean word of punctuation for indexing
                        const cleanWord = word.replace(/[^\w]/g, '');
                        // Filter out common words and keep meaningful terms
                        if (cleanWord.length > 3 && !['the', 'and', 'for', 'are', 'but', 'not', 'you', 'all', 'can', 'her', 'was', 'one', 'our', 'out', 'day', 'get', 'has', 'him', 'his', 'how', 'its', 'may', 'new', 'now', 'old', 'see', 'two', 'way', 'who', 'boy', 'did', 'its', 'let', 'put', 'say', 'she', 'too', 'use'].includes(cleanWord)) {
                            // Only index if the search term would match as a complete word or prefix
                            // This prevents substring matches like "hub" matching "hubble"
                            trie.insert(cleanWord, node);
                        }
                    });
                }
                if (node.explanation) {
                    const words = node.explanation.toLowerCase().split(/\s+/);
                    words.forEach(word => {
                        const cleanWord = word.replace(/[^\w]/g, '');
                        if (cleanWord.length > 3 && !['the', 'and', 'for', 'are', 'but', 'not', 'you', 'all', 'can', 'her', 'was', 'one', 'our', 'out', 'day', 'get', 'has', 'him', 'his', 'how', 'its', 'may', 'new', 'now', 'old', 'see', 'two', 'way', 'who', 'boy', 'did', 'its', 'let', 'put', 'say', 'she', 'too', 'use'].includes(cleanWord)) {
                            trie.insert(cleanWord, node);
                        }
                    });
                }
            }
            
            // Insert people names associated with this node
            if (node.people && Array.isArray(node.people)) {
                node.people.forEach(personName => {
                    trie.insert(personName, node);
                });
            }
            
            // Insert tags associated with this node
            if (node.tags && Array.isArray(node.tags)) {
                node.tags.forEach(tag => {
                    // Handle both string tags (legacy) and object tags with name and explanation
                    const tagName = typeof tag === 'string' ? tag : tag.name;
                    trie.insert(tagName, node);
                });
            }
            
            if (node.children) {
                node.children.forEach(child => {
                    buildTrie(child, trie);
                });
            }
        }

        // Global variables
        let trie = null;
        let anomalyTrie = null;
        let expandedNodes = new Set();
        let matchedNodes = new Set();
        let minYear = Infinity;
        let maxYear = -Infinity;
        let expandedBeforeSearch = new Set(); // Track nodes expanded before search
        let manuallyExpandedDuringSearch = new Set(); // Track nodes manually expanded during search
        let manuallyCollapsedDuringSearch = new Set(); // Track nodes manually collapsed during search
        let previousSearchTerm = ''; // Track previous search term to detect transitions

        // Find min and max years in the data (excluding root node)
        // Use a reasonable minimum year to ensure the oldest meaningful terms map to red
        function findYearRange(node, isRoot = true) {
            // Skip root node's year - only use actual physics terms
            if (!isRoot && node.year !== undefined) {
                minYear = Math.min(minYear, node.year);
                maxYear = Math.max(maxYear, node.year);
            }
            if (node.children) {
                node.children.forEach(child => findYearRange(child, false));
            }
        }

        // Map year to color (redshifted for old, blueshifted for recent)
        // Uses HSL color space: red (0¬∞) -> yellow (60¬∞) -> green (120¬∞) -> cyan (180¬∞) -> blue (240¬∞) -> violet (270¬∞)
        function yearToColor(year) {
            if (year === undefined || minYear === Infinity) {
                return '#e0e0ff'; // Default color
            }
            
            // Use today's year (2026) as the maximum to map to the violet end of the spectrum
            const currentYear = 2026;
            const maxYearForMapping = currentYear;
            
            // Normalize year to 0-1 range: minimum year from data -> today
            // Ensure we have a valid range
            const yearRange = maxYearForMapping - minYear;
            if (yearRange <= 0) {
                return '#e0e0ff'; // Default color if invalid range
            }
            
            const normalized = (year - minYear) / yearRange;
            
            // Clamp normalized value to [0, 1] in case any data is newer than current year
            const clampedNormalized = Math.max(0, Math.min(1, normalized));
            
            // Map to hue: red (0¬∞) for old -> violet (270¬∞) for recent
            // We'll use 0¬∞ to 270¬∞ to cover red -> yellow -> green -> cyan -> blue -> violet
            const hue = 270 * clampedNormalized; // Old = red (0¬∞), recent = violet (270¬∞)
            
            // Use high saturation and medium lightness for vibrant colors
            const saturation = 70 + (clampedNormalized * 20); // 70-90%
            const lightness = 50 + (clampedNormalized * 10); // 50-60%
            
            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }

        // Sort children by year at each hierarchy level
        function sortByYear(node) {
            if (node.children) {
                // Sort children by year (ascending - oldest first)
                node.children.sort((a, b) => {
                    const yearA = a.year !== undefined ? a.year : Infinity;
                    const yearB = b.year !== undefined ? b.year : Infinity;
                    return yearA - yearB;
                });
                // Recursively sort children
                node.children.forEach(child => sortByYear(child));
            }
        }

        // Set parent years to minimum of children (except root)
        function setParentYears(node, isRoot = true) {
            if (node.children && node.children.length > 0) {
                // Recursively process children first
                node.children.forEach(child => setParentYears(child, false));
                
                // Find minimum year among children
                const childYears = node.children
                    .map(child => child.year)
                    .filter(year => year !== undefined);
                
                if (childYears.length > 0 && !isRoot) {
                    const minChildYear = Math.min(...childYears);
                    node.year = minChildYear;
                }
            }
        }

        // Switch to a different view
        function switchView(view) {
            if (!consolidatedDataGlobal) {
                console.error('No consolidated data available');
                return;
            }

            currentView = view;
            
            // Update active tab
            document.querySelectorAll('.tab').forEach(tab => {
                if (tab.dataset.view === view) {
                    tab.classList.add('active');
                } else {
                    tab.classList.remove('active');
                }
            });

            // Convert to the selected view
            const hierarchy = getHierarchyForView(view, consolidatedDataGlobal);
            if (!hierarchy) {
                console.error('Failed to convert data to hierarchy');
                return;
            }

            // Use the converted hierarchical data
            sampleHierarchy = hierarchy;
            
            // Set parent years to minimum of children (except root which stays at 2026)
            setParentYears(sampleHierarchy, true);
            
            // Sort each hierarchy level by year
            sortByYear(sampleHierarchy);
            
            // Find year range for color mapping (excluding root node)
            minYear = Infinity;
            maxYear = -Infinity;
            findYearRange(sampleHierarchy, true);
            
            // Rebuild trie with new hierarchy
            trie = new Trie();
            buildTrie(sampleHierarchy, trie);
            
            // Clear search and refresh tree
            const searchBox = document.getElementById('searchBox');
            searchBox.value = '';
            previousSearchTerm = '';
            
            // Update search placeholder based on view
            const placeholders = {
                'concepts': 'Enter search criteria...',
                'people': 'Search people...',
                'tags': 'Search tags...',
                'papers': 'Search papers...'
            };
            searchBox.placeholder = placeholders[view] || 'Enter search criteria...';
            
            updateTree();
        }

        // Initialize data from script-loaded consolidated_data.js
        async function initializeData() {
            let consolidatedData;
            try {
                consolidatedData = await loadConsolidatedData();
            } catch (error) {
                console.error('Failed to load consolidated data:', error);
                document.getElementById('treeRoot').innerHTML = 
                    '<div class="no-results">Error: Failed to load consolidated_data.js. Please ensure data/output/consolidated_data.js is available.</div>';
                return;
            }

            if (!consolidatedData) {
                console.error('consolidatedData is null or undefined.');
                document.getElementById('treeRoot').innerHTML = 
                    '<div class="no-results">Error: consolidated_data.js not loaded. Please ensure data/output/consolidated_data.js is available.</div>';
                return;
            }

            // Store consolidated data globally for view switching
            consolidatedDataGlobal = consolidatedData;

            // Convert consolidated data format to hierarchical format based on current view
            const hierarchy = getHierarchyForView(currentView, consolidatedData);
            if (!hierarchy) {
                console.error('Failed to convert consolidated data to hierarchy');
                document.getElementById('treeRoot').innerHTML = 
                    '<div class="no-results">Error: Failed to process consolidated data.</div>';
                return;
            }

            // Use the converted hierarchical data
            sampleHierarchy = hierarchy;
            
            // Set parent years to minimum of children (except root which stays at 2026)
            setParentYears(sampleHierarchy, true);
            
            // Sort each hierarchy level by year
            sortByYear(sampleHierarchy);
            
            // Find year range for color mapping (excluding root node)
            minYear = Infinity;
            maxYear = -Infinity;
            findYearRange(sampleHierarchy, true);
            
            // Debug: log the year range
            
            // Initialize trie with loaded data
            trie = new Trie();
            buildTrie(sampleHierarchy, trie);
            
            // Initialize tree display
            updateTree();

            // Initialize anomaly tree
            initializeAnomalyTree(consolidatedData);

            // Add tab click handlers
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    const view = tab.dataset.view;
                    switchView(view);
                });
            });
        }

        // Build anomaly hierarchy grouped by theory
        function buildAnomalyHierarchy(consolidatedData) {
            if (!consolidatedData || !consolidatedData.data || !consolidatedData.data.anomaly) {
                return null;
            }

            const anomalies = consolidatedData.data.anomaly;
            const theories = consolidatedData.data.theory || {};
            const violatedAssumptions = consolidatedData.data.violated_assumption || {};

            // Group anomalies by theory_id
            const anomaliesByTheory = {};
            Object.values(anomalies).forEach(anomaly => {
                const theoryId = anomaly.theory_id;
                if (!anomaliesByTheory[theoryId]) {
                    anomaliesByTheory[theoryId] = [];
                }
                anomaliesByTheory[theoryId].push(anomaly);
            });

            // Build hierarchy: Theory -> Anomalies -> Violated Assumptions
            const root = {
                name: 'Anomalies',
                year: 2026,
                children: []
            };

            Object.keys(anomaliesByTheory).forEach(theoryId => {
                const theory = theories[theoryId];
                if (!theory) return;

                const theoryNode = {
                    name: theory.name || theoryId,
                    year: theory.year || 0,
                    summary: `Theory: ${theory.name}`,
                    theory_id: theoryId,
                    children: []
                };

                anomaliesByTheory[theoryId].forEach(anomaly => {
                    const anomalyNode = {
                        name: anomaly.name,
                        year: anomaly.discovery_year || 0,
                        summary: anomaly.description || '',
                        anomaly_id: anomaly.anomaly_id,
                        explanation: anomaly.explanation || '',
                        explanation_theory_id: anomaly.explanation_theory_id,
                        children: []
                    };

                    // Add violated assumptions as children (they're nested objects, not IDs)
                    if (anomaly.violated_assumptions && Array.isArray(anomaly.violated_assumptions)) {
                        anomaly.violated_assumptions.forEach(violatedAssumption => {
                            if (typeof violatedAssumption === 'object' && violatedAssumption !== null) {
                                const desc = violatedAssumption.violation_description || 'Assumption violated';
                                anomalyNode.children.push({
                                    name: `Violated: ${desc.substring(0, 60)}${desc.length > 60 ? '...' : ''}`,
                                    year: anomaly.discovery_year || 0,
                                    summary: desc,
                                    assumption_id: violatedAssumption.assumption_id,
                                    violated_assumption_id: violatedAssumption.violated_assumption_id
                                });
                            }
                        });
                    }

                    // Add violated claims
                    if (anomaly.violated_claims && Array.isArray(anomaly.violated_claims)) {
                        anomaly.violated_claims.forEach(claimId => {
                            anomalyNode.children.push({
                                name: `Violated Claim: ${claimId}`,
                                year: anomaly.discovery_year || 0,
                                summary: `Claim ${claimId} is violated`,
                                claim_id: claimId
                            });
                        });
                    }

                    theoryNode.children.push(anomalyNode);
                });

                root.children.push(theoryNode);
            });

            // Sort by year
            root.children.sort((a, b) => (a.year || 0) - (b.year || 0));
            root.children.forEach(theoryNode => {
                theoryNode.children.sort((a, b) => (a.year || 0) - (b.year || 0));
            });

            return root;
        }

        // Initialize anomaly tree
        function initializeAnomalyTree(consolidatedData) {
            const anomalyHierarchy = buildAnomalyHierarchy(consolidatedData);
            if (!anomalyHierarchy) {
                document.getElementById('anomalyTreeRoot').innerHTML = 
                    '<div class="no-results">No anomalies found</div>';
                return;
            }

            // Set parent years
            setParentYears(anomalyHierarchy, true);
            
            // Sort by year
            sortByYear(anomalyHierarchy);
            
            // Build trie for anomaly search
            anomalyTrie = new Trie();
            buildTrie(anomalyHierarchy, anomalyTrie);
            
            // Update anomaly tree display
            updateAnomalyTree();
            
            // Store for later use
            window.anomalyHierarchy = anomalyHierarchy;
        }

        // Update anomaly tree display
        // Uses identical logic to updateTree for consistency
        function updateAnomalyTree(searchTerm = '') {
            if (!window.anomalyHierarchy) {
                return;
            }

            const treeRoot = document.getElementById('anomalyTreeRoot');
            treeRoot.innerHTML = '';
            
            // Clear previous matched nodes for anomalies
            const anomalyMatchedNodes = new Set();
            const anomalyVisibleNodes = new Set();
            
            if (searchTerm.trim() && anomalyTrie) {
                // Find matching nodes in anomaly tree
                const matches = anomalyTrie.searchSubstring(searchTerm);
                
                matches.forEach(node => {
                    anomalyMatchedNodes.add(node.name);
                    // Mark this node and all its ancestors as visible
                    markAncestorsVisible(node, window.anomalyHierarchy, anomalyVisibleNodes);
                });
                
                // Always include root in visible nodes
                if (window.anomalyHierarchy) {
                    anomalyVisibleNodes.add(window.anomalyHierarchy.name);
                }
                
                // Build final expanded nodes set (same logic as updateTree)
                const finalExpandedNodes = new Set();
                
                // Track which nodes have matched children - auto-expand parents to show matches
                const nodesWithMatchedChildren = new Set();
                matches.forEach(matchedNode => {
                    const parent = findParentNode(window.anomalyHierarchy, matchedNode);
                    if (parent) nodesWithMatchedChildren.add(parent.name);
                });
                
                // 1. Keep manually expanded nodes from before search (if still visible)
                expandedBeforeSearch.forEach(nodeName => {
                    if (anomalyVisibleNodes.has(nodeName)) {
                        finalExpandedNodes.add(nodeName);
                    }
                });
                
                // 2. Keep manually expanded nodes during search (make them visible)
                manuallyExpandedDuringSearch.forEach(nodeName => {
                    finalExpandedNodes.add(nodeName);
                    findAndMarkNodeVisible(window.anomalyHierarchy, nodeName, anomalyVisibleNodes);
                });
                
                // 3. Auto-expand nodes with matched children (unless manually collapsed)
                nodesWithMatchedChildren.forEach(nodeName => {
                    if (!manuallyCollapsedDuringSearch.has(nodeName)) {
                        finalExpandedNodes.add(nodeName);
                    }
                });
                
                // 4. Remove manually collapsed nodes and their descendants
                removeCollapsedAndDescendants(window.anomalyHierarchy, manuallyCollapsedDuringSearch, finalExpandedNodes);
                
                expandedNodes = finalExpandedNodes;
            } else {
                // No search: all nodes are visible
                const markAllVisible = (node) => {
                    anomalyVisibleNodes.add(node.name);
                    if (node.children) {
                        node.children.forEach(child => markAllVisible(child));
                    }
                };
                markAllVisible(window.anomalyHierarchy);
            }
            
            renderAnomalyTree(window.anomalyHierarchy, treeRoot, searchTerm, anomalyVisibleNodes, anomalyMatchedNodes);
            
            // Show "no results" message if searching and no matches found
            const noResultsDiv = document.getElementById('anomalyNoResults');
            if (searchTerm.trim() && anomalyMatchedNodes.size === 0 && anomalyVisibleNodes.size <= 1) {
                // Only show "no results" if no matches AND only root is visible (no manually expanded nodes)
                noResultsDiv.style.display = 'block';
            } else {
                noResultsDiv.style.display = 'none';
            }
        }

        // Render anomaly tree (similar to renderTree but for anomalies)
        function renderAnomalyTree(node, parentElement, searchTerm = '', visibleNodes = null, matchedNodes = null) {
            // If searching and visibleNodes is set, only render if this node is visible
            const isRoot = parentElement.id === 'anomalyTreeRoot';
            if (visibleNodes && visibleNodes.size > 0 && !isRoot) {
                if (!visibleNodes.has(node.name)) {
                    return false; // Don't render this node if it's not visible
                }
            }
            
            const li = document.createElement('li');
            li.className = 'tree-node';
            li.dataset.nodeName = node.name;

            const content = document.createElement('div');
            content.className = 'tree-node-content';
            
            const hasChildren = node.children && node.children.length > 0;
            const isExpanded = expandedNodes.has(node.name);
            const isMatched = matchedNodes && matchedNodes.has(node.name);
            const isHighlighted = searchTerm && node.name.toLowerCase().includes(searchTerm.toLowerCase());

            // Apply year-based color
            if (node.year !== undefined) {
                const yearColor = yearToColor(node.year);
                const opacity = isMatched || isHighlighted ? '60' : '40';
                content.style.borderLeft = `4px solid ${yearColor}`;
                content.style.boxShadow = `0 0 10px ${yearColor}${opacity}`;
            }

            if (isMatched) {
                content.classList.add('matched');
            } else if (isHighlighted) {
                content.classList.add('highlight');
            }

            // Toggle button
            const toggle = document.createElement('span');
            toggle.className = 'tree-toggle';
            if (!hasChildren) {
                toggle.classList.add('no-children');
                toggle.textContent = '‚Ä¢';
            } else {
                toggle.textContent = isExpanded ? '‚ñº' : '‚ñ∂';
                if (!isExpanded) {
                    toggle.classList.add('collapsed');
                }
                toggle.onclick = (e) => {
                    e.stopPropagation();
                    const searchBox = document.getElementById('searchBox');
                    const currentSearchTerm = searchBox ? searchBox.value : '';
                    toggleNode(node.name);
                    updateAnomalyTree(currentSearchTerm);
                    updateTree(currentSearchTerm); // Also update main tree in case of shared nodes
                };
            }

            // Label
            const label = document.createElement('span');
            label.className = 'tree-label';
            label.textContent = node.name;
            if (node.year) {
                label.textContent += ` (${node.year})`;
            }
            
            label.onclick = () => {
                if (hasChildren) {
                    const searchBox = document.getElementById('searchBox');
                    const currentSearchTerm = searchBox ? searchBox.value : '';
                    toggleNode(node.name);
                    updateAnomalyTree(currentSearchTerm);
                    updateTree(currentSearchTerm); // Also update main tree in case of shared nodes
                } else {
                    // Show details in modal if available
                    if (node.summary || node.explanation) {
                        showAnomalyDetails(node);
                    }
                }
            };

            content.appendChild(toggle);
            content.appendChild(label);
            li.appendChild(content);

            // Children
            if (hasChildren) {
                const childrenUl = document.createElement('ul');
                childrenUl.className = 'tree-children';
                
                // During search, show filtered children OR all children if manually expanded
                let childrenToShow;
                if (searchTerm.trim() && visibleNodes && visibleNodes.size > 0 && !isExpanded) {
                    // Not expanded: only show children that match the search filter
                    childrenToShow = node.children.filter(child => visibleNodes.has(child.name));
                } else if (isExpanded) {
                    // Manually expanded: show ALL children regardless of search filter
                    childrenToShow = node.children;
                } else {
                    // No search: show all children
                    childrenToShow = node.children;
                }
                
                // Set visibility: if expanded OR if there are visible children to show (during search)
                const shouldShowChildren = isExpanded || (searchTerm.trim() && childrenToShow.length > 0);
                if (shouldShowChildren) {
                    childrenUl.classList.remove('hidden');
                } else {
                    childrenUl.classList.add('hidden');
                }
                
                // If this node is manually expanded, render all children even if they don't match the search filter
                const forceChildrenVisible = isExpanded;
                childrenToShow.forEach(child => {
                    renderAnomalyTree(child, childrenUl, searchTerm, visibleNodes, matchedNodes);
                });
                
                li.appendChild(childrenUl);
            }

            parentElement.appendChild(li);
            return true; // Indicate that the node was rendered
        }

        // Show anomaly details in modal
        function showAnomalyDetails(node) {
            const modal = document.getElementById('contextModal');
            const title = document.getElementById('contextModalTitle');
            const year = document.getElementById('contextModalYear');
            const summary = document.getElementById('contextModalSummary');

            title.textContent = node.name;
            if (node.year !== undefined) {
                year.textContent = `Year: ${node.year}`;
                // Apply year-based color to the year text
                const yearColor = yearToColor(node.year);
                year.style.color = yearColor;
                year.style.textShadow = `
                    0 0 5px ${yearColor},
                    0 0 10px ${yearColor}80,
                    0 0 15px ${yearColor}60
                `;
            } else {
                year.textContent = '';
                year.style.color = '';
                year.style.textShadow = '';
            }
            summary.textContent = node.summary || node.explanation || 'No description available';

            // Hide other modal sections
            document.getElementById('contextModalTags').style.display = 'none';
            document.getElementById('contextModalPeople').style.display = 'none';
            document.getElementById('contextModalPapers').style.display = 'none';
            document.getElementById('contextModalNobel').style.display = 'none';
            document.getElementById('contextModalWikipedia').style.display = 'none';

            // Use the same method as the main modal (classList.add('active'))
            modal.classList.add('active');
            currentModalNode = node;
        }

        function renderTree(node, parentElement, searchTerm = '', visibleNodes = null, forceVisible = false) {
            // If searching and visibleNodes is set, only render if this node is visible
            // Root node (when parentElement is treeRoot) is always visible
            // forceVisible: if true, render this node even if not in visibleNodes (for children of manually expanded nodes)
            const isRoot = parentElement.id === 'treeRoot';
            if (visibleNodes && visibleNodes.size > 0 && !isRoot && !forceVisible) {
                if (!visibleNodes.has(node.name)) {
                    return false; // Don't render this node if it's not visible
                }
            }
            
            const li = document.createElement('li');
            li.className = 'tree-node';
            li.dataset.nodeName = node.name;

            const content = document.createElement('div');
            content.className = 'tree-node-content';
            
            const hasChildren = node.children && node.children.length > 0;
            const isExpanded = expandedNodes.has(node.name);
            const isMatched = matchedNodes.has(node.name);
            
            const isHighlighted = searchTerm && node.name.toLowerCase().includes(searchTerm.toLowerCase());
            
            // Removed verbose logging

            // Apply year-based color (preserved even when matched/highlighted)
            if (node.year !== undefined) {
                const yearColor = yearToColor(node.year);
                // Use year color for border, but adjust opacity based on state
                const opacity = isMatched || isHighlighted ? '60' : '40';
                content.style.borderLeft = `4px solid ${yearColor}`;
                content.style.boxShadow = `0 0 10px ${yearColor}${opacity}`;
            }

            if (isMatched) {
                content.classList.add('matched');
            } else if (isHighlighted) {
                content.classList.add('highlight');
            }

            // Toggle button
            const toggle = document.createElement('span');
            toggle.className = 'tree-toggle';
            if (!hasChildren) {
                toggle.classList.add('no-children');
                toggle.textContent = '‚Ä¢';
            } else {
                // Double-check expansion state to ensure button matches
                const actualExpanded = expandedNodes.has(node.name);
                toggle.textContent = actualExpanded ? '‚ñº' : '‚ñ∂';
                if (!actualExpanded) {
                    toggle.classList.add('collapsed');
                } else {
                    toggle.classList.remove('collapsed');
                }
                toggle.onclick = (e) => {
                    e.stopPropagation();
                    toggleNode(node.name);
                };
            }

            // Label with year display
            const label = document.createElement('span');
            label.className = 'tree-label';
            let labelText;
            if (node.year !== undefined) {
                // Add "-" after year for parent nodes (nodes with children)
                const yearSuffix = hasChildren ? '-' : '';
                labelText = `${node.name} (${node.year}${yearSuffix})`;
            } else {
                labelText = node.name;
            }
            label.textContent = labelText;
            
            // Apply year color as a glow effect (text-shadow)
            if (node.year !== undefined) {
                const yearColor = yearToColor(node.year);
                // Create a glow effect using text-shadow with multiple layers
                label.style.textShadow = `
                    0 0 5px ${yearColor},
                    0 0 10px ${yearColor},
                    0 0 15px ${yearColor}80,
                    0 0 20px ${yearColor}60
                `;
            }
            
            // Handle click: toggle for parents, open context modal for leaf nodes
            const handleClick = (e) => {
                // Don't stop propagation if clicking on toggle button (it has its own handler)
                if (e.target.classList.contains('tree-toggle')) {
                    return;
                }
                e.stopPropagation();
                if (hasChildren) {
                    toggleNode(node.name);
                } else {
                    // Leaf node - check if it's an assumption, postulate, claim, or prediction
                    // If so, open the parent theory modal instead
                    if (node.name.startsWith('Assumption:') || 
                        node.name.startsWith('Postulate:') || 
                        node.name.startsWith('Claim:') ||
                        node.name.startsWith('Prediction:')) {
                        if (node.parentTheory) {
                            openContextModal(node.parentTheory);
                        } else {
                            // Fallback: try to find parent in hierarchy
                            const parentNode = findParentTheory(node, sampleHierarchy);
                            if (parentNode) {
                                openContextModal(parentNode);
                            } else {
                                openContextModal(node);
                            }
                        }
                    } else {
                        // Regular leaf node - open context modal
                        openContextModal(node);
                    }
                }
            };
            
            // Make both label and content clickable
            label.onclick = handleClick;
            content.onclick = handleClick;
            
            // Style leaf nodes to look clickable
            if (!hasChildren) {
                label.style.cursor = 'pointer';
                label.style.textDecoration = 'underline';
                label.style.textDecorationColor = 'rgba(184, 184, 255, 0.3)';
                content.style.cursor = 'pointer';
                
                // Add tooltip for leaf nodes with summaries
                if (node.summary) {
                    let tooltipText = node.summary;
                    
                    // For predictions, add verification details to tooltip
                    if (node.name.startsWith('Prediction:')) {
                        const details = [];
                        if (node.prediction_year) {
                            details.push(`Predicted: ${node.prediction_year}`);
                        }
                        if (node.verification_year) {
                            details.push(`Verified: ${node.verification_year}`);
                        }
                        if (node.verification_method) {
                            details.push(`Method: ${node.verification_method}`);
                        }
                        if (node.status) {
                            details.push(`Status: ${node.status}`);
                        }
                        if (details.length > 0) {
                            // Format tooltip with verification details
                            // CSS content doesn't support newlines, so use a readable separator
                            tooltipText = `${node.summary}\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n${details.join('\n')}`;
                        }
                    }
                    
                    // Add tooltip to the content div for better positioning
                    content.classList.add('tree-tooltip');
                    content.setAttribute('data-tooltip', tooltipText);
                }
            } else {
                // Parent nodes should also look clickable
                content.style.cursor = 'pointer';
            }

            content.appendChild(toggle);
            content.appendChild(label);
            li.appendChild(content);

            // Children
            if (hasChildren) {
                const childrenUl = document.createElement('ul');
                childrenUl.className = 'tree-children';
                
                // If searching, show children based on visibility
                // BUT: if this node is manually expanded, show ALL children regardless of filter
                // This allows users to expand nodes to see all children even when searching
                let childrenToShow;
                if (searchTerm.trim() && visibleNodes && visibleNodes.size > 0 && !isExpanded) {
                    // Not expanded: only show children that match the search filter
                    childrenToShow = node.children.filter(child => visibleNodes.has(child.name));
                } else if (isExpanded) {
                    // Manually expanded: show ALL children regardless of search filter
                    childrenToShow = node.children;
                } else {
                    // No search: show all children
                    childrenToShow = node.children;
                }
                
                // Set visibility: if expanded OR if there are visible children to show (during search)
                const shouldShowChildren = isExpanded || (searchTerm.trim() && childrenToShow.length > 0);
                if (shouldShowChildren) {
                    childrenUl.classList.remove('hidden');
                } else {
                    childrenUl.classList.add('hidden');
                }

                // Removed verbose logging
                
                // If this node is manually expanded, render all children even if they don't match the search filter
                const forceChildrenVisible = isExpanded;
                childrenToShow.forEach(child => {
                    renderTree(child, childrenUl, searchTerm, visibleNodes, forceChildrenVisible);
                });

                li.appendChild(childrenUl);
            }

            parentElement.appendChild(li);
            return true; // Indicate that the node was rendered
        }

        function toggleNode(nodeName) {
            // Get current search term from the search box
            const searchBox = document.getElementById('searchBox');
            const currentSearchTerm = searchBox ? searchBox.value : '';
            const isSearching = currentSearchTerm.trim();
            
            // Toggle the expansion state
            const wasExpanded = expandedNodes.has(nodeName);
            
            if (wasExpanded) {
                expandedNodes.delete(nodeName);
                if (isSearching) {
                    manuallyExpandedDuringSearch.delete(nodeName);
                    manuallyCollapsedDuringSearch.add(nodeName);
                }
                
                // Cascade collapse: collapse all descendants too
                // This ensures that when a user collapses a node, all children collapse even if they match the search
                const collapseDescendants = (node) => {
                    if (node.children) {
                        node.children.forEach(child => {
                            expandedNodes.delete(child.name);
                            if (isSearching) {
                                manuallyExpandedDuringSearch.delete(child.name);
                                manuallyCollapsedDuringSearch.add(child.name);
                            }
                            collapseDescendants(child);
                        });
                    }
                };
                
                // Find and collapse the node's descendants in both trees
                const findAndCollapse = (currentNode, targetName) => {
                    if (currentNode.name === targetName) {
                        collapseDescendants(currentNode);
                        return true;
                    }
                    if (currentNode.children) {
                        for (let child of currentNode.children) {
                            if (findAndCollapse(child, targetName)) {
                                return true;
                            }
                        }
                    }
                    return false;
                };
                
                if (sampleHierarchy) findAndCollapse(sampleHierarchy, nodeName);
                if (window.anomalyHierarchy) findAndCollapse(window.anomalyHierarchy, nodeName);
            } else {
                expandedNodes.add(nodeName);
                if (isSearching) {
                    manuallyExpandedDuringSearch.add(nodeName);
                    manuallyCollapsedDuringSearch.delete(nodeName);
                }
            }
            
            // Pass the toggled node name and flag to indicate this is a manual toggle
            // This ensures the toggle state is preserved even if there are visibility edge cases
            updateTree(currentSearchTerm, true, nodeName);
            
            // Also update anomaly tree if it exists
            if (window.anomalyHierarchy) {
                updateAnomalyTree(currentSearchTerm);
            }
        }

        function updateTree(searchTerm = '', isManualToggle = false, toggledNodeName = null) {
            if (!sampleHierarchy || !trie) {
                return; // Data not loaded yet
            }

            const treeRoot = document.getElementById('treeRoot');
            const noResults = document.getElementById('noResults');
            treeRoot.innerHTML = '';

            // Check if we're transitioning from search to no search
            const wasSearching = previousSearchTerm.trim().length > 0;
            const isNowSearching = searchTerm.trim().length > 0;
            
            // If search is cleared (transitioning from search to no search), collapse all nodes
            if (!isNowSearching && wasSearching) {
                expandedNodes.clear();
                expandedBeforeSearch.clear();
                manuallyExpandedDuringSearch.clear();
                manuallyCollapsedDuringSearch.clear();
            }
            // If starting a new search, save current expansion state
            else if (isNowSearching && !wasSearching && expandedBeforeSearch.size === 0) {
                expandedBeforeSearch = new Set(expandedNodes);
                manuallyExpandedDuringSearch.clear(); // Clear any previous manual expansions
                // DO NOT clear manuallyCollapsedDuringSearch - preserve user's manual collapses across search changes
            }
            
            // Update previous search term
            previousSearchTerm = searchTerm;

            matchedNodes.clear();

            // Build set of nodes that should be visible (matched nodes and their ancestors)
            const visibleNodes = new Set();
            
            if (searchTerm.trim()) {
                // Find matching nodes using trie (substring search to match both node names and people names)
                const matches = trie.searchSubstring(searchTerm);
                
                matches.forEach(node => {
                    matchedNodes.add(node.name);
                    // Mark this node and all its ancestors as visible
                    markAncestorsVisible(node, sampleHierarchy, visibleNodes);
                });
                
                // Always include root in visible nodes
                if (sampleHierarchy) {
                    visibleNodes.add(sampleHierarchy.name);
                }
                
                // Build final expanded nodes set
                const finalExpandedNodes = new Set();
                
                // Track which nodes have matched children - auto-expand parents to show matches
                const nodesWithMatchedChildren = new Set();
                matches.forEach(matchedNode => {
                    const parent = findParentNode(sampleHierarchy, matchedNode);
                    if (parent) nodesWithMatchedChildren.add(parent.name);
                });
                
                // 1. Keep manually expanded nodes from before search (if still visible)
                expandedBeforeSearch.forEach(nodeName => {
                    if (visibleNodes.has(nodeName)) {
                        finalExpandedNodes.add(nodeName);
                    }
                });
                
                // 2. Keep manually expanded nodes during search (make them visible)
                manuallyExpandedDuringSearch.forEach(nodeName => {
                    finalExpandedNodes.add(nodeName);
                    findAndMarkNodeVisible(sampleHierarchy, nodeName, visibleNodes);
                });
                
                // 3. Auto-expand nodes with matched children (unless manually collapsed)
                nodesWithMatchedChildren.forEach(nodeName => {
                    if (!manuallyCollapsedDuringSearch.has(nodeName)) {
                        finalExpandedNodes.add(nodeName);
                    }
                });
                
                // 4. Remove manually collapsed nodes and their descendants
                removeCollapsedAndDescendants(sampleHierarchy, manuallyCollapsedDuringSearch, finalExpandedNodes);
                
                expandedNodes = finalExpandedNodes;

                if (matches.length === 0) {
                    treeRoot.style.display = 'none';
                    noResults.style.display = 'block';
                } else {
                    treeRoot.style.display = 'block';
                    noResults.style.display = 'none';
                }
            } else {
                // No search - all nodes are visible (empty set means show all)
                visibleNodes.clear();
                // expandedNodes was already cleared above when search is empty
                // User can now manually expand nodes
                treeRoot.style.display = 'block';
                noResults.style.display = 'none';
            }
            renderTree(sampleHierarchy, treeRoot, searchTerm, visibleNodes);
            updateStats();
        }

        // Mark a node and all its ancestors as visible
        function markAncestorsVisible(targetNode, currentNode, visibleNodes, path = []) {
            if (currentNode === targetNode) {
                // Mark this node and all nodes in the path as visible
                path.forEach(node => {
                    visibleNodes.add(node.name);
                });
                visibleNodes.add(targetNode.name);
                return true;
            }

            if (currentNode.children) {
                for (let child of currentNode.children) {
                    if (markAncestorsVisible(targetNode, child, visibleNodes, [...path, currentNode])) {
                        // Also mark the current node as visible since it's in the path
                        visibleNodes.add(currentNode.name);
                        return true;
                    }
                }
            }

            return false;
        }

        // Shared helper: Find parent of a target node in a hierarchy
        function findParentNode(currentNode, targetNode, parentNode = null) {
            if (currentNode === targetNode) {
                return parentNode;
            }
            if (currentNode.children) {
                for (let child of currentNode.children) {
                    const result = findParentNode(child, targetNode, currentNode);
                    if (result !== null) {
                        return result;
                    }
                }
            }
            return null;
        }

        // Shared helper: Find and mark a node and its path as visible
        function findAndMarkNodeVisible(currentNode, targetName, visibleNodes, path = []) {
            if (currentNode.name === targetName) {
                // Mark this node and all ancestors as visible
                path.forEach(ancestor => {
                    visibleNodes.add(ancestor.name);
                });
                visibleNodes.add(targetName);
                // Also mark all children as visible when manually expanded
                if (currentNode.children) {
                    currentNode.children.forEach(child => {
                        visibleNodes.add(child.name);
                    });
                }
                return true;
            }
            if (currentNode.children) {
                for (let child of currentNode.children) {
                    if (findAndMarkNodeVisible(child, targetName, visibleNodes, [...path, currentNode])) {
                        visibleNodes.add(currentNode.name);
                        return true;
                    }
                }
            }
            return false;
        }

        // Shared helper: Remove collapsed nodes and their descendants from expanded set
        function removeCollapsedAndDescendants(currentNode, collapsedSet, expandedSet) {
            if (collapsedSet.has(currentNode.name)) {
                // This node is collapsed, remove it and all its descendants
                expandedSet.delete(currentNode.name);
                if (currentNode.children) {
                    currentNode.children.forEach(child => {
                        expandedSet.delete(child.name);
                        removeCollapsedAndDescendants(child, collapsedSet, expandedSet);
                    });
                }
            } else if (currentNode.children) {
                // Check children recursively
                currentNode.children.forEach(child => {
                    removeCollapsedAndDescendants(child, collapsedSet, expandedSet);
                });
            }
        }

        function expandAncestors(targetNode, currentNode, path = []) {
            if (currentNode === targetNode) {
                // Expand all nodes in the path
                path.forEach(node => expandedNodes.add(node.name));
                return true;
            }

            if (currentNode.children) {
                for (let child of currentNode.children) {
                    if (expandAncestors(targetNode, child, [...path, currentNode])) {
                        return true;
                    }
                }
            }

            return false;
        }

        // Count only leaf nodes (concepts, not categories)
        function countConcepts(node) {
            if (!node.children || node.children.length === 0) {
                // Leaf node - this is a concept
                return 1;
            }
            // Parent node - count its children
            let count = 0;
            node.children.forEach(child => {
                count += countConcepts(child);
            });
            return count;
        }

        // Count all unique people across all nodes
        function countPeople(node) {
            const peopleSet = new Set();
            
            function collectPeople(n) {
                if (n.people && Array.isArray(n.people)) {
                    n.people.forEach(person => peopleSet.add(person));
                }
                if (n.children) {
                    n.children.forEach(child => collectPeople(child));
                }
            }
            
            collectPeople(node);
            return peopleSet.size;
        }

        // Count all unique tags across all nodes
        function countTags(node) {
            const tagsSet = new Set();
            
            function collectTags(n) {
                if (n.tags && Array.isArray(n.tags)) {
                    n.tags.forEach(tag => {
                        // Handle both string tags (legacy) and object tags with name and explanation
                        const tagName = typeof tag === 'string' ? tag : tag.name;
                        tagsSet.add(tagName);
                    });
                }
                if (n.children) {
                    n.children.forEach(child => collectTags(child));
                }
            }
            
            collectTags(node);
            return tagsSet.size;
        }

        // Count all papers across all nodes
        function countPapers(node) {
            let paperCount = 0;
            
            function collectPapers(n) {
                if (n.papers && Array.isArray(n.papers)) {
                    paperCount += n.papers.length;
                }
                if (n.children) {
                    n.children.forEach(child => collectPapers(child));
                }
            }
            
            collectPapers(node);
            return paperCount;
        }

        function updateStats() {
            if (!sampleHierarchy) {
                return; // Data not loaded yet
            }
            const totalConcepts = countConcepts(sampleHierarchy);
            const totalPeople = countPeople(sampleHierarchy);
            const totalTags = countTags(sampleHierarchy);
            const totalPapers = countPapers(sampleHierarchy);
            const matchCount = matchedNodes.size;
            document.getElementById('conceptCount').textContent = `Total concepts: ${totalConcepts}`;
            document.getElementById('peopleCount').textContent = `Total people: ${totalPeople}`;
            document.getElementById('tagCount').textContent = `Total tags: ${totalTags}`;
            document.getElementById('paperCount').textContent = `Total papers: ${totalPapers}`;
            document.getElementById('matchCount').textContent = `Matches: ${matchCount}`;
        }

        // Context Modal Functions
        let currentModalNode = null;

        // Helper function to find parent theory of an assumption/postulate/claim
        function findParentTheory(childNode, rootNode) {
            if (!rootNode || !rootNode.children) {
                return null;
            }
            
            // Check if any child is the target node
            for (const child of rootNode.children) {
                if (child === childNode || (child.name && childNode.name && child.name === childNode.name)) {
                    // Found the child, return the root as parent
                    return rootNode;
                }
                // Recursively search in children
                const found = findParentTheory(childNode, child);
                if (found) {
                    return found;
                }
            }
            
            return null;
        }

        // Helper function to find a node by name in the hierarchy
        function findNodeByName(node, name) {
            if (node.name === name) {
                return node;
            }
            if (node.children) {
                for (let child of node.children) {
                    const found = findNodeByName(child, name);
                    if (found) return found;
                }
            }
            return null;
        }

        function openContextModal(node) {
            // Find the full node from the hierarchy to ensure we have all properties including summary
            // The node passed in should already have all properties, but we'll verify by looking it up
            let nodeToUse = node;
            
            // Try to find it in the hierarchy to ensure we have the complete node
            if (sampleHierarchy) {
                const foundNode = findNodeByName(sampleHierarchy, node.name);
                if (foundNode) {
                    nodeToUse = foundNode;
                }
            }
            
            currentModalNode = nodeToUse;
            
            const modal = document.getElementById('contextModal');
            const title = document.getElementById('contextModalTitle');
            const year = document.getElementById('contextModalYear');
            const summary = document.getElementById('contextModalSummary');
            const tagsContainer = document.getElementById('contextModalTags');
            const peopleContainer = document.getElementById('contextModalPeople');
            const papersContainer = document.getElementById('contextModalPapers');
            const nobelContainer = document.getElementById('contextModalNobel');

            title.textContent = nodeToUse.name;
            if (nodeToUse.year !== undefined) {
                year.textContent = `Year: ${nodeToUse.year}`;
                // Apply year-based color to the year text
                const yearColor = yearToColor(nodeToUse.year);
                year.style.color = yearColor;
                year.style.textShadow = `
                    0 0 5px ${yearColor},
                    0 0 10px ${yearColor}80,
                    0 0 15px ${yearColor}60
                `;
            } else {
                year.textContent = '';
                year.style.color = '';
                year.style.textShadow = '';
            }

            // Check for summary property - it should be directly on the node
            if (nodeToUse.summary && typeof nodeToUse.summary === 'string' && nodeToUse.summary.trim() !== '') {
                summary.textContent = nodeToUse.summary;
                summary.style.display = 'block';
            } else {
                summary.textContent = 'No summary available.';
                summary.style.display = 'block';
            }

            // Display tags
            tagsContainer.innerHTML = '';
            if (nodeToUse.tags && Array.isArray(nodeToUse.tags) && nodeToUse.tags.length > 0) {
                const tagsLabel = document.createElement('div');
                tagsLabel.className = 'context-modal-tags-label';
                tagsLabel.textContent = 'Tags:';
                tagsContainer.appendChild(tagsLabel);

                const tagsList = document.createElement('div');
                tagsList.className = 'context-modal-tags-list';

                nodeToUse.tags.forEach(tag => {
                    const tagElement = document.createElement('span');
                    tagElement.className = 'context-modal-tag';
                    
                    // Handle both string tags (legacy) and object tags with name and explanation
                    const tagName = typeof tag === 'string' ? tag : tag.name;
                    const tagExplanation = typeof tag === 'object' && tag.explanation ? tag.explanation : null;
                    
                    tagElement.textContent = tagName;
                    
                    // Add tooltip if explanation exists
                    if (tagExplanation) {
                        const tooltip = document.createElement('span');
                        tooltip.className = 'context-modal-tag-tooltip';
                        tooltip.textContent = tagExplanation;
                        tagElement.appendChild(tooltip);
                    }
                    
                    tagsList.appendChild(tagElement);
                });

                tagsContainer.appendChild(tagsList);
                tagsContainer.style.display = 'block';
            } else {
                tagsContainer.style.display = 'none';
            }

            // Display people
            peopleContainer.innerHTML = '';
            if (nodeToUse.people && Array.isArray(nodeToUse.people) && nodeToUse.people.length > 0) {
                const peopleLabel = document.createElement('div');
                peopleLabel.className = 'context-modal-people-label';
                peopleLabel.textContent = 'Key People:';
                peopleContainer.appendChild(peopleLabel);

                const peopleList = document.createElement('div');
                peopleList.className = 'context-modal-people-list';

                nodeToUse.people.forEach(personName => {
                    const personLink = document.createElement('a');
                    personLink.className = 'context-modal-person';
                    personLink.textContent = personName;
                    personLink.href = `https://en.wikipedia.org/wiki/${encodeURIComponent(personName)}`;
                    personLink.target = '_blank';
                    personLink.rel = 'noopener noreferrer';
                    peopleList.appendChild(personLink);
                });

                peopleContainer.appendChild(peopleList);
                peopleContainer.style.display = 'block';
            } else {
                peopleContainer.style.display = 'none';
            }

            // Display papers
            papersContainer.innerHTML = '';
            if (nodeToUse.papers && Array.isArray(nodeToUse.papers) && nodeToUse.papers.length > 0) {
                // Get papers from consolidated data (papers array contains paper IDs)
                const papers = consolidatedDataGlobal && consolidatedDataGlobal.data 
                    ? consolidatedDataGlobal.data.paper || {} 
                    : {};
                
                // Resolve paper IDs to paper objects
                const paperObjects = [];
                nodeToUse.papers.forEach(paperId => {
                    if (typeof paperId === 'string') {
                        // It's a paper ID, look it up
                        const paper = papers[paperId];
                        if (paper) {
                            paperObjects.push(paper);
                        }
                    } else if (typeof paperId === 'object' && paperId.title) {
                        // It's already a paper object (legacy format)
                        paperObjects.push(paperId);
                    }
                });

                if (paperObjects.length > 0) {
                    const papersLabel = document.createElement('div');
                    papersLabel.className = 'context-modal-papers-label';
                    papersLabel.textContent = 'Key Papers:';
                    papersContainer.appendChild(papersLabel);

                    const papersList = document.createElement('div');
                    papersList.className = 'context-modal-papers-list';

                    paperObjects.forEach(paper => {
                        const paperLink = document.createElement('a');
                        paperLink.className = 'context-modal-paper';
                        paperLink.textContent = paper.title || 'Unknown Paper';
                        paperLink.href = paper.link || '#';
                        paperLink.target = '_blank';
                        paperLink.rel = 'noopener noreferrer';
                        papersList.appendChild(paperLink);
                    });

                    papersContainer.appendChild(papersList);
                    papersContainer.style.display = 'block';
                } else {
                    papersContainer.style.display = 'none';
                }
            } else {
                papersContainer.style.display = 'none';
            }

            // Display Prize information from consolidated data
            nobelContainer.innerHTML = '';
            let hasPrizeInfo = false;

            // Get prize data from consolidated data
            if (consolidatedDataGlobal && consolidatedDataGlobal.data) {
                const prizes = consolidatedDataGlobal.data.prize || {};
                const prizeAwards = consolidatedDataGlobal.data.prize_award || {};
                const people = consolidatedDataGlobal.data.person || {};

                // Get theory_id from the node (stored during hierarchy building)
                const theoryId = nodeToUse.theory_id;

                // Find all prize awards related to this theory or people
                const relevantAwards = [];
                Object.values(prizeAwards).forEach(award => {
                    // Check if award is for this theory
                    if (theoryId && award.theory_id === theoryId) {
                        relevantAwards.push(award);
                    }
                    // Check if award is for any of the people
                    if (nodeToUse.people && Array.isArray(nodeToUse.people)) {
                        // nodeToUse.people contains person_ids (from consolidated data)
                        nodeToUse.people.forEach(personId => {
                            if (award.people && award.people.includes(personId)) {
                                if (!relevantAwards.find(a => a.award_id === award.award_id)) {
                                    relevantAwards.push(award);
                                }
                            }
                        });
                    }
                });

                // Group awards by prize
                const awardsByPrize = {};
                relevantAwards.forEach(award => {
                    const prizeId = award.prize_id;
                    if (!awardsByPrize[prizeId]) {
                        awardsByPrize[prizeId] = [];
                    }
                    awardsByPrize[prizeId].push(award);
                });

                // Display prizes
                Object.keys(awardsByPrize).forEach(prizeId => {
                    const prize = prizes[prizeId];
                    if (!prize) return;

                    const awards = awardsByPrize[prizeId];
                    const prizeIcon = prize.category === 'Kyoto Prize in Basic Sciences' ? 'üèÖ' : 
                                    prize.category.includes('Chemistry') ? 'üß™' :
                                    prize.category.includes('Medicine') ? '‚öïÔ∏è' :
                                    prize.category.includes('Economic') ? 'üí∞' : 'üèÜ';

                    hasPrizeInfo = true;

                    // Prize label
                    const label = document.createElement('div');
                    label.className = 'context-modal-nobel-label';
                    label.innerHTML = `${prizeIcon} ${prize.name}`;
                    nobelContainer.appendChild(label);

                    // Display each award
                    awards.forEach(award => {
                        const awardDiv = document.createElement('div');
                        awardDiv.className = 'context-modal-nobel-topic';

                        const yearDiv = document.createElement('div');
                        yearDiv.className = 'context-modal-nobel-topic-year';
                        yearDiv.textContent = `${award.year}`;
                        awardDiv.appendChild(yearDiv);

                        const descDiv = document.createElement('div');
                        descDiv.className = 'context-modal-nobel-topic-description';
                        descDiv.textContent = award.description;
                        awardDiv.appendChild(descDiv);

                        // Display people who received this award
                        if (award.people && award.people.length > 0) {
                            const peopleDiv = document.createElement('div');
                            peopleDiv.className = 'context-modal-nobel-people';
                            peopleDiv.style.marginTop = '10px';

                            const peopleLabel = document.createElement('div');
                            peopleLabel.className = 'context-modal-nobel-people-label';
                            peopleLabel.textContent = 'Awarded to:';
                            peopleDiv.appendChild(peopleLabel);

                            const peopleList = document.createElement('div');
                            peopleList.className = 'context-modal-nobel-people-list';

                            award.people.forEach(personId => {
                                const person = people[personId];
                                if (person) {
                                    const personElement = document.createElement('a');
                                    personElement.className = 'context-modal-nobel-person';
                                    personElement.textContent = person.name;
                                    personElement.href = `https://en.wikipedia.org/wiki/${encodeURIComponent(person.name)}`;
                                    personElement.target = '_blank';
                                    personElement.rel = 'noopener noreferrer';
                                    personElement.style.cursor = 'pointer';
                                    personElement.style.textDecoration = 'underline';
                                    personElement.style.textDecorationColor = 'rgba(255, 215, 0, 0.5)';

                                    const yearElement = document.createElement('span');
                                    yearElement.className = 'context-modal-nobel-person-year';
                                    yearElement.textContent = ` (${award.year})`;
                                    personElement.appendChild(yearElement);

                                    peopleList.appendChild(personElement);
                                }
                            });

                            peopleDiv.appendChild(peopleList);
                            awardDiv.appendChild(peopleDiv);
                        }

                        nobelContainer.appendChild(awardDiv);
                    });
                });
            }

            if (hasPrizeInfo) {
                nobelContainer.style.display = 'block';
            } else {
                nobelContainer.style.display = 'none';
            }

            modal.classList.add('active');
        }

        function closeContextModal() {
            const modal = document.getElementById('contextModal');
            modal.classList.remove('active');
            currentModalNode = null;
        }

        // Convert name to Wikipedia URL format (spaces to underscores, handle apostrophes)
        function nameToWikipediaUrl(name) {
            // Replace spaces with underscores (Wikipedia's format)
            // Keep apostrophes but they'll be encoded by encodeURIComponent
            return name.replace(/\s+/g, '_');
        }

        function openWikipedia() {
            if (currentModalNode) {
                // Use underscores instead of spaces for better Wikipedia compatibility
                const wikiName = nameToWikipediaUrl(currentModalNode.name);
                const wikipediaUrl = `https://en.wikipedia.org/wiki/${encodeURIComponent(wikiName)}`;
                window.open(wikipediaUrl, '_blank');
                closeContextModal();
            }
        }

        // Modal event listeners
        document.getElementById('contextModalClose').addEventListener('click', closeContextModal);
        document.getElementById('contextModalCancel').addEventListener('click', closeContextModal);
        document.getElementById('contextModalWikipedia').addEventListener('click', openWikipedia);

        // Close modal when clicking outside
        document.getElementById('contextModal').addEventListener('click', (e) => {
            if (e.target.id === 'contextModal') {
                closeContextModal();
            }
        });

        // Close modal with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeContextModal();
            }
        });

        // Search box event listener
        const searchBox = document.getElementById('searchBox');
        searchBox.addEventListener('input', (e) => {
            const searchTerm = e.target.value;
            updateTree(searchTerm);
            updateAnomalyTree(searchTerm);
        });

        // Initialize data on startup (data.js is loaded via script tag)
        // Use async IIFE to handle async initialization
        (async () => {
            await initializeData();
        })();
    </script>
</body>
</html>